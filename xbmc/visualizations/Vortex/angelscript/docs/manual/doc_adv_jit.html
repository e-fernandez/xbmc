<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: JIT compilation</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_adv_jit">JIT compilation </a></h1>AngelScript doesn't provide a built-in JIT compiler, instead it permits an external JIT compiler to be implemented through a public interface.<p>
To use JIT compilation, the scripts must be compiled with a few extra instructions that provide hints to the JIT compiler and also entry points so that the VM will know when to pass control to the JIT compiled function. By default this is turned off, and must thus be turned on by setting the engine property <a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f7ff74f4afa490b55839daaf217cf898c">asEP_INCLUDE_JIT_INSTRUCTIONS</a>.<p>
If the application sets the <a class="el" href="classas_i_j_i_t_compiler.html">JIT compiler</a> with <a class="el" href="classas_i_script_engine.html#ee4f910163604203a27db1ffea3b1c9c">SetJITCompiler</a> AngelScript will automatically invoke it to provide the <a class="el" href="angelscript_8h.html#c8d421a0baba134571f1672bf6b55901">JIT functions</a> with each compilation or <a class="el" href="doc_adv_precompile.html">loading of pre-compiled bytecode</a>.<h2><a class="anchor" name="doc_adv_jit_3">
The structure of the JIT function</a></h2>
The <a class="el" href="angelscript_8h.html#c8d421a0baba134571f1672bf6b55901">JIT compiled function</a> must follow certain rules in order to behave well with the virtual machine. The intention is that the VM will pass the control to the JIT function, and when the execution is to be suspended the JIT function returns the control to the VM, updating the internal state of the VM so that the VM can resume the execution when requested. Each time the JIT function returns control to the VM it must make sure that the <a class="el" href="structas_s_v_m_registers.html">VM registers</a> and stack values have been updated according to the code that was executed.<p>
The byte code will have a special instruction, <a class="el" href="angelscript_8h.html#b3692c4e5d47fc93f8c9646d1783aef06705ee9692b45f118cfe0ea24581fae5">JitEntry</a>, which defines the positions where the VM can pass the control to the JIT function. These are usually placed for every script statement, and after each instruction that calls another function. This implies that the JIT compiled function needs to be able to start the execution at different points based on the argument in the JitEntry instruction. The value of the argument is defined by the JIT compiler and how it is interpreted is also up to the JIT compiler, with the exception of 0 that means that the control should not be passed to the JIT function.<p>
Some byte code instructions are not meant to be converted into native code. These are usually the ones that have a more global effect on the VM, e.g. the instructions that setup a call to a new script function, or that return from a previous instruction. When these functions are encountered, the JIT function should return the control to the VM, and then the VM will execute the instruction.<p>
Other byte code instructions may be partially implemented by the JIT function, for example those that can throw an exception based on specific conditions. One such example is the instructions for divisions, if the divider is 0 the VM will set an exception and abort the execution. For these instructions the JIT compiler should preferrably implement the condition that doesn't throw an exception, and if an exception is to be thrown the JIT function will instead break out to the VM.<p>
The following shows a possible structure of a JIT compiled function:<p>
<pre>
  void jitCompiledFunc(asSVMRegisters *regs, asDWORD entry)
  {
    Read desired VM registers into CPU registers
    Jump to the current position of the function based on the 'entry' argument
  1:
    Execute code in block 1
    Jump to exit if an illegal operation is done, e.g. divide by zero. 
    Jump to exit if block ends with an instruction that should not be executed by JIT function. 
  2:
    ...
  3:
    ...
  exit:
    Update the VM registers before returning control to VM
  }
</pre><h2><a class="anchor" name="doc_adv_jit_2">
Traversing the byte code</a></h2>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> CJITCompiler::CompileFunction(<a class="code" href="classas_i_script_function.html" title="The interface for a script function description.">asIScriptFunction</a> *func, <a class="code" href="angelscript_8h.html#c8d421a0baba134571f1672bf6b55901" title="The function signature of a JIT compiled function.">asJITFunction</a> *output)
{
  <span class="keywordtype">bool</span> success = StartNewCompilation();

  <span class="comment">// Get the script byte code</span>
  <a class="code" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815" title="32 bit unsigned integer">asUINT</a>   length;
  <a class="code" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc" title="32 bit unsigned integer">asDWORD</a> *byteCode = func-&gt;<a class="code" href="classas_i_script_function.html#fb38e9ba77ce8b49378e43dadd83ef94" title="Returns the byte code buffer and length.">GetByteCode</a>(&amp;length);
  <a class="code" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc" title="32 bit unsigned integer">asDWORD</a> *end = byteCode + length;
  
  <span class="keywordflow">while</span>( byteCode &lt; end )
  {
    <span class="comment">// Determine the instruction</span>
    <a class="code" href="angelscript_8h.html#b3692c4e5d47fc93f8c9646d1783aef0" title="The bytecode instructions used by the VM.">asEBCInstr</a> op = <a class="code" href="angelscript_8h.html#b3692c4e5d47fc93f8c9646d1783aef0" title="The bytecode instructions used by the VM.">asEBCInstr</a>(*(<a class="code" href="angelscript_8h.html#48b3da7121b3abb56bff63b3beb0df63" title="8 bit unsigned integer">asBYTE</a>*)byteCode);
    <span class="keywordflow">switch</span>( op )
    {
    <span class="comment">// Translate each byte code instruction into native code.</span>
    <span class="comment">// The codes that cannot be translated should return the control</span>
    <span class="comment">// to the VM, so that it can continue the processing. When </span>
    <span class="comment">// the VM encounters the next JitEntry instruction it will</span>
    <span class="comment">// transfer the control back to the JIT function.</span>
    ...
    
    <span class="keywordflow">case</span> <a class="code" href="angelscript_8h.html#b3692c4e5d47fc93f8c9646d1783aef06705ee9692b45f118cfe0ea24581fae5" title="If a JIT function is available and the argument is not 0 then call the JIT function...">asBC_JitEntry</a>:
      <span class="comment">// Update the argument for the JitEntry instruction with  </span>
      <span class="comment">// the argument that should be sent to the jit function.</span>
      <span class="comment">// Remember that 0 means that the VM should not pass</span>
      <span class="comment">// control to the JIT function.</span>
      <a class="code" href="angelscript_8h.html#2287157faea7f6d32b316c17e0858ddf" title="Macro to access the first signed WORD argument in the bytecode instruction.">asBC_SWORDARG0</a>(byteCode) = DetermineJitEntryArg();
      <span class="keywordflow">break</span>;
    }
    
    <span class="comment">// Move to next instruction</span>
    byteCode += <a class="code" href="angelscript_8h.html#60edaa2f8001e7405f073ab3b1ad51ac" title="Lookup table for determining the size of each type of bytecode instruction.">asBCTypeSize</a>[<a class="code" href="angelscript_8h.html#c58d23b688ddd6d6e788b034daf25df7" title="Information on each bytecode instruction.">asBCInfo</a>[op].<a class="code" href="structas_s_b_c_info.html#a0579956f325760177250e0eddd52ab4" title="Instruction argument layout.">type</a>];
  }
  
  <span class="keywordflow">if</span>( success )
  {
    *output = GetCompiledFunction();
    <span class="keywordflow">return</span> 0;
  }
  
  <span class="keywordflow">return</span> -1;
}
</pre></div><p>
The following macros should be used to read the arguments from the bytecode instruction. The layout of the arguments is determined from the <a class="el" href="angelscript_8h.html#c58d23b688ddd6d6e788b034daf25df7">asBCInfo</a> array.<p>
<ul>
<li><a class="el" href="angelscript_8h.html#7b3dbfcc3928ddd853a4ee53cbc13b69">asBC_DWORDARG</a></li><li><a class="el" href="angelscript_8h.html#290586f7a153d5e8717b01680262b667">asBC_INTARG</a></li><li><a class="el" href="angelscript_8h.html#92e1437ea399e8c545e15bffd651f45f">asBC_QWORDARG</a></li><li><a class="el" href="angelscript_8h.html#0183edd413564ff4897eb4a2473d01f6">asBC_FLOATARG</a></li><li><a class="el" href="angelscript_8h.html#ac9eb586274fc44bb1b838d833963996">asBC_PTRARG</a></li><li><a class="el" href="angelscript_8h.html#942798ec89a8ac96550523d80570c703">asBC_WORDARG0</a></li><li><a class="el" href="angelscript_8h.html#0a704bf4db31deda2a69d3216312618c">asBC_WORDARG1</a></li><li><a class="el" href="angelscript_8h.html#2287157faea7f6d32b316c17e0858ddf">asBC_SWORDARG0</a></li><li><a class="el" href="angelscript_8h.html#92601565873cf5d29a6876c2638d7fec">asBC_SWORDARG1</a></li><li><a class="el" href="angelscript_8h.html#698449bbbe369b8a479fb0dd82c9b18e">asBC_SWORDARG2</a></li></ul>
<p>
What each <a class="el" href="angelscript_8h.html#b3692c4e5d47fc93f8c9646d1783aef0">byte code</a> instruction does is described in <a class="el" href="doc_adv_jit_1.html">Byte code instructions</a>, but the exact implementation of each byte code instruction is best determined from the implementation in the VM, i.e. the asCScriptContext::ExecuteNext method. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Dec 16 19:34:50 2009 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
