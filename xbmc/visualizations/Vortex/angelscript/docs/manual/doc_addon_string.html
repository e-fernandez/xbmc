<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: string object (reference counted)</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_addon_string">string object (reference counted) </a></h1><b>Path:</b> /sdk/add_on/scriptstring/<p>
This add-on registers a string type that is in most situations compatible with the <code>std::string</code>, except that it uses reference counting. This means that if you have an application function that takes a <code>std::string</code> by reference, you can register it with AngelScript to take a script string by reference. This works because the CScriptString wraps the <code>std::string</code> type, with the std::string type at the first byte of the CScriptString object.<p>
Register the type with <code>RegisterScriptString(asIScriptEngine*)</code>. Register the utility functions with <code>RegisterScriptStringUtils(asIScriptEngine*)</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_addon_std_string.html">string object (STL)</a></dd></dl>
<h2><a class="anchor" name="doc_addon_string_1">
Public C++ interface</a></h2>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CScriptString
{
<span class="keyword">public</span>:
  <span class="comment">// Constructors</span>
  CScriptString();
  CScriptString(<span class="keyword">const</span> CScriptString &amp;other);
  CScriptString(<span class="keyword">const</span> <span class="keywordtype">char</span> *s);
  CScriptString(<span class="keyword">const</span> std::string &amp;s);

  <span class="comment">// Memory management</span>
  <span class="keywordtype">void</span> AddRef();
  <span class="keywordtype">void</span> Release();

  <span class="comment">// Assignment</span>
  CScriptString &amp;operator=(<span class="keyword">const</span> CScriptString &amp;other);
  
  <span class="comment">// Concatenation</span>
  CScriptString &amp;operator+=(<span class="keyword">const</span> CScriptString &amp;other);
  <span class="keyword">friend</span> CScriptString *operator+(<span class="keyword">const</span> CScriptString &amp;a, <span class="keyword">const</span> CScriptString &amp;b);
  
  <span class="comment">// Memory buffer</span>
  std::string buffer;
};
</pre></div><h2><a class="anchor" name="doc_addon_string_2">
Public script interface</a></h2>
<pre>
  class string
  {
    // Constructors
    string();
    string(const string &amp;in other);</pre><p>
<pre>    // Returns the length of the string
    uint length() const;</pre><p>
<pre>    // Assignment and concatenation
    string &amp;opAssign(const string &amp;in other);
    string &amp;opAddAssign(const string &amp;in other);
    string @opAdd(const string &amp;in right) const;</pre><p>
<pre>    // Access individual characters
    // uint8 &amp;operator [] (uint)
    // const uint8 &amp;operator [] (uint) const</pre><p>
<pre>    // Comparison operators
    bool opEquals(const string &amp;in right) const;
    int  opCmp(const string &amp;in right) const;</pre><p>
<pre>    // Automatic conversion from number types to string type
    string &amp;opAssign(double val);
    string &amp;opAddAssign(double val);
    string @opAdd(double val) const;
    string @opAdd_r(double val) const;</pre><p>
<pre>    string &amp;opAssign(float val);
    string &amp;opAddAssign(float val);
    string @opAdd(float val) const;
    string @opAdd_r(float val) const;</pre><p>
<pre>    string &amp;opAssign(int val);
    string &amp;opAddAssign(int val);
    string @opAdd(int val) const;
    string @opAdd_r(int val) const;</pre><p>
<pre>    string &amp;opAssign(uint val);
    string &amp;opAddAssign(uint val);
    string @opAdd(uint val) const;
    string @opAdd_r(uint val) const;
  }</pre><p>
<pre>  // Get a substring of a string
  string @ substring(const string &amp;in str, int start, int length);</pre><p>
<pre>  // Find the first occurrance of the substring
  int findFirst(const string &amp;in str, const string &amp;in sub);
  int findFirst(const string &amp;in str, const string &amp;in sub, int startAt)</pre><p>
<pre>  // Find the last occurrance of the substring
  int findLast(const string &amp;in str, const string &amp;in sub);
  int findLast(const string &amp;in str, const string &amp;in sub, int startAt);</pre><p>
<pre>  // Find the first character from the set 
  int findFirstOf(const string &amp;in str, const string &amp;in set);
  int findFirstOf(const string &amp;in str, const string &amp;in set, int startAt);</pre><p>
<pre>  // Find the first character not in the set
  int findFirstNotOf(const string &amp;in str, const string &amp;in set);
  int findFirstNotOf(const string &amp;in str, const string &amp;in set, int startAt);</pre><p>
<pre>  // Find the last character from the set
  int findLastOf(const string &amp;in str, const string &amp;in set);
  int findLastOf(const string &amp;in str, const string &amp;in set, int startAt);</pre><p>
<pre>  // Find the last character not in the set
  int findLastNotOf(const string &amp;in str, const string &amp;in set);
  int findLastNotOf(const string &amp;in str, const string &amp;in set, int startAt);</pre><p>
<pre>  // Split the string into an array of substrings
  string@[]@ split(const string &amp;in str, const string &amp;in delimiter);</pre><p>
<pre>  // Join an array of strings into a larger string separated by a delimiter
  string@ join(const string@[] &amp;in str, const string &amp;in delimiter);
</pre> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Dec 16 19:34:50 2009 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
